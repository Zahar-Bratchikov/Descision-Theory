import numpy as np


# Функция для поиска решения симплекс-методом с выводом промежуточных таблиц
def simplex_method(c, A, b):
    m, n = A.shape  # m - количество ограничений, n - количество переменных

    # Шаг 1: Формирование расширенной симплекс-таблицы
    # Создаем таблицу для симплекс-метода, где добавляются искусственные переменные
    table = np.zeros(
        (m + 1, n + m + 1))  # Дополнительная строка для целевой функции и дополнительный столбец для правой части
    table[:-1, :-1] = np.hstack((A, np.eye(m)))  # Добавляем матрицу ограничений и искусственные переменные
    table[:-1, -1] = b  # Правая часть ограничений
    table[-1, :-1] = np.hstack((-c, np.zeros(m)))  # Коэффициенты целевой функции

    while True:
        # Шаг 4: Проверка условия оптимальности (все σn ≤ 0)
        # Если в последней строке есть положительные элементы, продолжаем решение
        col = np.argmin(table[-1, :-1])  # Находим минимальный элемент в строке целевой функции
        if table[-1, col] >= 0:  # Если все элементы >= 0, решение найдено
            break

        # Шаг 5: Выбор разрешающего столбца (переменной, вводимой в базис)
        ratios = []  # Список для вычисления соотношений
        for i in range(m):
            if table[i, col] > 0:  # Если элемент столбца положительный
                ratios.append(table[i, -1] / table[i, col])  # Вычисляем отношение
            else:
                ratios.append(np.inf)  # Если элемент столбца отрицательный или 0, записываем бесконечность

        # Шаг 6: Проверка условия, если все элементы в разрешающем столбце отрицательны
        if all(r == np.inf for r in ratios):  # Если все соотношения бесконечны, задача не имеет решения
            raise Exception("Задача не имеет решения")

        # Шаг 7: Выбор разрешающей строки (переменной, выводимой из базиса)
        row = np.argmin(ratios)  # Находим строку с минимальным отношением
        if all(r == np.inf for r in ratios):  # Если все отношения равны бесконечности
            raise Exception("Задача не имеет решения")

        # Шаг 8: Пересчет элементов симплекс-таблицы
        # Обновляем разрешающую строку (делим все элементы строки на разрешающий элемент)
        table[row, :] /= table[row, col]

        # Обновляем остальные строки таблицы, используя правило прямоугольника
        for i in range(m + 1):
            if i != row:
                table[i, :] -= table[i, col] * table[row, :]

    # Возвращаем решение
    solution = np.zeros(n)  # Массив для хранения решения
    for j in range(n):  # Для каждой переменной
        col_values = table[:-1, j]  # Значения в столбце переменной
        if np.count_nonzero(col_values) == 1 and table[-1, j] == 0:  # Если в столбце только одна единица
            row = np.where(col_values == 1)[0][0]  # Находим строку с единицей
            solution[j] = table[row, -1]  # Записываем решение для этой переменной

    return solution, table[-1, -1]  # Возвращаем решение и значение целевой функции


# Определение целевой функции и ограничений
c = np.array([2, 2], dtype=float)  # Коэффициенты целевой функции
A = np.array([
    [-3, 2],  # -3x1 + 2x2 <= 6
    [-1, -1],  # -x1 - x2 <= -3
    [1, 0],  # x1 <= 3
    [0, 1]  # x2 <= 5
], dtype=float)
b = np.array([6, -3, 3, 5], dtype=float)  # Правая часть ограничений

# Решение задачи
solution, max_value = simplex_method(c, A, b)

# Вывод результатов
print("\nОптимальное решение:")
print(f"x1 = {solution[0]:.2f}, x2 = {solution[1]:.2f}")
print(f"Максимальное значение целевой функции: F = {max_value:.2f}")
